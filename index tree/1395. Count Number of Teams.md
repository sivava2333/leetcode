# 1. 原题链接/Link
[1395. Count Number of Teams](https://leetcode.com/problems/count-number-of-teams/)

# 2. 思路/Approach
题目要求找出三个士兵组成一个队伍，他们的能力值必须是升序或者降序的，有多少种组法。其中每个士兵的能力值都是不同的

+ 暴力解/Intuitive  
最直观的办法就是按照题目要求去遍历数组：  
[0,length-3]范围上每个士兵为i  
[i+1,length-2]范围上每个士兵为j  
[j+1,length-1]范围上每个是兵为k  
组成所有的队伍中，符合条件的个数
Time Complexity: O(n^3)  
Space Complexity: O(1)  

+ 树状数组/Index tree  
如果以每个位置作为j士兵，能知道  
1.他的左侧有多少个士兵能力值比他大，能力值比他少  
2.他的右侧有多少士兵能力值比他大，能力值比他小  
则：  
1.能力值升序的队伍的个数：左侧能力值小的人数 * 右侧能力值大的人数  
2.能力值降序的队伍的个数：左侧能力值大的人数 * 右侧能力值小的人数  

使用树状数组快速查找左侧和右侧能力值大的和小的士兵人数  

Time Complexity: O(n * logn)  
Space Complexity: O(n) 

# 3. 代码
```
class Solution {
    public int numTeams1(int[] rating) {
        
    }
    
    // 树状数组
    public int numTeams2(int[] rating) {
        // rating的取值范围大于rating的长度，需要做离散化处理
        TreeSet<Integer> set = new TreeSet<>();
        for (int i : rating) {
            set.add(i);
        }
        
    }
    
    /**
    * 树状数组
    */
    class IndexTree {
        public int size;
        public int[] it;
        
        public IndexTree(int n) {
            size = n + 1;
            it = new int[size];
        }
        
        public void add(int index) {
            while (index < size) {
                it[index]++;
                index += index & -index;
            }
        }
        
        public int query(int index) {
            int ret = 0;
            while (index > 0) {
                ret += it[index];
                index -= index & -index;
            }
        }
    }
}
```
